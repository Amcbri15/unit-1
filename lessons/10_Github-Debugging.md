### Github and Debugging

#### Objective
Students will learn general software engineering practices and will be able
to navigate Git, have more available debugging tools at their disposal,
and learn the basics of exception handling. 

#### Pre-Work

[Github & Git Foundations](https://www.youtube.com/playlist?list=PLg7s6cbtAD15G8lNyoaYDuKZSKyJrgwB-)

#### Do Now (Morning)

Create a new Java class to do the following string operations:
* Reverse - "Quispe" -> "epsiuQ"
* Uppercase words - "i love java" -> "I Love Java"
* Reverse words - "Java Love I" -> "I Love Java"
* Parse Addition Expression - "3 + (4 + 2)" -> "9". Assume that the only operations are "+" and parentheses.

#### Git and Github

*Git* is a version control system. *Github* is a very popular website for storing git repositories and collaborating.

> Exercise: Partner with the other person at your table.

> Part I: Fork and Pull

> 1. Create a repository on Github.

> 1. Clone the repository locally, add the Do Now, and push the change to Github.

> 1. Fork your partner's repository.

> 1. Clone the fork of your partner's repository locally.

> 1. Set the upstream to your partner's repository.

> 1. Create a new branch and make changes to the file in your partner's repository.

> 1. Commit and push this change to Github.

> 1. Open a pull request to your partner's repository master.

> 1. Code review the pull request from your partner.

> 1. Respond to all the changes requested on your pull request (either make the change or push back), and push your changes.

> 1. Accept your partner's pull request.

> Part II: Merge Conflict

> 1. Make your partner a collaborator on your repository.

> 1. Sync your local clone of your repository to origin master.

> 1. Clone your partner's repository locally.

> 1. Make changes to the file in your partner's repository and push.

> 1. Make changes to the file in your own repository and commit.

> 1. Before pushing, sync to origin master.

> 1. Resolve any merge conflicts.

> 1. Push your changes to your repository.

> Part III: Shared repository

> 1. Sync your local clone of your partner's repository to origin master.

> 1. Create a new branch on your partner's repository.

> 1. Push this branch to Github.

> 1. Make changes to the file on this branch and push.

> 1. Open a pull request from this branch to master.

> 1. Code review your partner's pull request on your repository.

> 1. Respond to all comments on your partner's code review on your pull request (either make changes or push back) and push your changes.

> 1. Go back and forth code reviewing and responding to comments until all comments are resolved.

> 1. If comments can't be resolved, ask a third party to weigh in on your pull requst.

> 1. Once all comments are resolved, accept your partner's pull request.

> 1. Sync your local clones of your repositories to origin master, and delete all resolved branches.

#### Do Now (Afternoon)

Find the pull request for your reviewee from this week's code review. Download and run their horoscope app. If there are any problems with the pull request, please work with your reviewee to fix this pull request. 

#### Debugging Basics

##### Printing

Printing is a very useful debugging method that you've probably already touched.

##### Logging



##### Reading Stack Traces

Stack traces tell you where

##### Using the Debugger

> Exercise: Debug [BuggyClass](exercises/10_Github-Debugging/src/BuggyClass.java). BuggyClass attemps to compare several different array addition algorithms, but it's fraught with bugs. Remember, bugs are problems with functionality, not just crashing. It may be tricky to infer what someone *meant* to do with the code - in the future you may have to deal with (and fix!) poorly-documented code written by someone who is no longer at the company, or is otherwise not contactable.

#### Exception Handling

Exceptions are errors generated by your program. These errors normally crash your program, but you can write code to `catch` them and recover.

First, let's see how to raise an exception. For example, let's say you had a `myDivide` method. Since dividing by zero isn't defined arithmetically, we should raise an exception.

```
public static double myDivide(int dividend, int divisor) {
    if(divisor == 0){
        throw new IllegalArgumentException("Dividing By Zero");
    }
    // implement division here
    .
    .
    .
}
```

Once an exception is raised, calling code may handle it. For example, let's say you are using the `myDivide` API for a calculator application.

```
public static void myCalculator(String userInput) {
    .
    . // parse userInput
    .
      .
        try {
            myDivide(num1, num2);
        }
        catch (IllegalArgumentException e) {
            alert_user(e.getMessage());
        }
      .
    .
    .
    .
}
```

Here, we use the exception to alert the user as to what went wrong. Exceptions propogate up the call stack, so the method that called `myCalculator` can also handle the exception. If the exception gets to the top of the call stack, then the program crashes.

#### Assessment


